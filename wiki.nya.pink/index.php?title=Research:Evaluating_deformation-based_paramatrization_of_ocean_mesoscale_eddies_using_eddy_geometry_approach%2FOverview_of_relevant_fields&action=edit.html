<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>View source for Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields - Lab Journal Wiki</title>
<script>document.documentElement.className="client-js";RLCONF={"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields","wgTitle":"Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields","wgCurRevisionId":604,"wgRevisionId":0,"wgArticleId":26,"wgIsArticle":!1,"wgIsRedirect":!1,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":!0,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep",
"Oct","Nov","Dec"],"wgRelevantPageName":"Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields","wgRelevantArticleId":26,"wgRequestId":"bbb26a360587cef83afc4f2c","wgCSPNonce":!1,"wgIsProbablyEditable":!1,"wgRelevantPageIsProbablyEditable":!1,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMediaViewerOnClick":!0,"wgMediaViewerEnabledByDefault":!0};RLSTATE={"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","ext.scite.styles":"ready","ext.smw.style":"ready","ext.smw.tooltip.styles":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"};RLPAGEMODULES=["ext.smw.style","ext.smw.table.styles","smw.factbox","mediawiki.action.edit.collapsibleFooter","site","mediawiki.page.startup","mediawiki.page.ready","mediawiki.searchSuggest",
"ext.scite.styles","ext.scite.tooltip","skins.vector.js"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.tokens@tffin",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link rel="stylesheet" href="load.php%3Flang=en&amp;modules=ext.scite.styles|ext.smw.style|ext.smw.tooltip.styles&amp;only=styles&amp;skin=vector.css"/>
<link rel="stylesheet" href="load.php%3Flang=en&amp;modules=mediawiki.legacy.commonPrint,shared|mediawiki.skinning.interface|skins.vector.styles&amp;only=styles&amp;skin=vector.css"/>
<script async="" src="load.php%3Flang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="generator" content="MediaWiki 1.34.2"/>
<meta name="robots" content="noindex,nofollow"/>
<link rel="alternate" type="application/rdf+xml" title="Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields" href="./index.php%3Ftitle=Special:ExportRDF%252FResearch:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;xmlmime=rdf"/>
<link rel="shortcut icon" href="favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Lab Journal Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="api.php%3Faction=rsd"/>
<!--[if lt IE 9]><script src="/resources/lib/html5shiv/html5shiv.js"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Research_Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach_Overview_of_relevant_fields rootpage-Research_Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach skin-vector action-edit">
<div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	
	<div class="mw-indicators mw-body-content">
</div>

	<h1 id="firstHeading" class="firstHeading" lang="en">View source for Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields</h1>
	
	<div id="bodyContent" class="mw-body-content">
		
		<div id="contentSub">‚Üê <a href="wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html" title="Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields">Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields</a></div>
		
		
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="./index.php%3Ftitle=Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;action=edit.html#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="./index.php%3Ftitle=Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;action=edit.html#p-search">Jump to search</a>
		<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in the group: <a href="https://wiki.nya.pink/index.php?title=Lab_Journal_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Lab Journal Wiki:Users (page does not exist)">Users</a>.
</p>
</div><hr />
<p>You can view and copy the source of this page.
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" class="mw-editfont-monospace" lang="en" dir="ltr" name="wpTextbox1">Let's make some plots.

==Streamfunction==

===Streamfunction statistics===

First, let's compute the time mean and standard deviation of the streamfunction:

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

# compute mean psi field
psi &lt;- readRDS("~/working/jet_time_model_data/1.Rds")
psi_mean &lt;- matrix(0L, nrow = dim(psi)[1], ncol = dim(psi)[2])
psi_sq_mean &lt;- matrix(0L, nrow = dim(psi)[1], ncol = dim(psi)[2])
for (i in 1:1000) {
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/@{i}.Rds"))
  psi_mean &lt;- psi_mean + psi
  psi_sq_mean &lt;- psi_sq_mean + psi^2
  print(i)
}
psi_mean &lt;- psi_mean / 1000
psi_sq_mean &lt;- psi_sq_mean / 1000

psi_std &lt;- sqrt(psi_sq_mean - psi_mean^2 + 3e-14) # need 3e-14 because of numerical errors?

# save for later usage
saveRDS(psi_mean, "~/working/jet_stat_model_data/psi_mean.Rds")
saveRDS(psi_sq_mean, "~/working/jet_stat_model_data/psi_sq_mean.Rds")
saveRDS(psi_std, "~/working/jet_stat_model_data/psi_std.Rds")
&lt;/syntaxhighlight>
|Code to compute streamfunction statistics
}}

{{collapse|
&lt;syntaxhighlight lang="R">
# load data
psi_mean &lt;- readRDS("~/working/jet_stat_model_data/psi_mean.Rds")
psi_sq_mean &lt;- readRDS("~/working/jet_stat_model_data/psi_sq_mean.Rds")
psi_std &lt;- readRDS("~/working/jet_stat_model_data/psi_std.Rds")

# plot
png(file="streamfunction_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(psi_mean,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Steamfunction (mean)")
dev.off()

png(file="streamfunction_std.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(psi_std,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Steamfunction (std)")
dev.off()

png(file="streamfunction_meridional_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(psi_mean),
     xlab="y",
     ylab="Averaged meridional streamfunction (mean)")
dev.off()

png(file="streamfunction_zonal_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(psi_mean),
     xlab="x",
     ylab="Averaged zonal streamfunction (mean)")
dev.off()

png(file="streamfunction_meridional_std.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(psi_std),
     xlab="y",
     ylab="Averaged meridional streamfunction (std)")
dev.off()

png(file="streamfunction_zonal_std.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(psi_std),
     xlab="x",
     ylab="Averaged zonal streamfunction (std)")
dev.off()

# TODO:
# image(psi_std > 0.03)
# imagep(psi_std,zlim=c(0,0.03),decimate=FALSE)
# hist(psi_std)
# hist(psi_std, xlim=c(0.0031,0.3))
# ROUGHLY: there are three regions: 0 to 0.03, 0.03 to 0.3, and 0.3 to 0.6.
&lt;/syntaxhighlight>
|Code to plot streamfunction statistics
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation streamfunction mean.png|Mean
File:Eddy geometry deformation streamfunction std.png|STD
File:Eddy geometry deformation streamfunction meridional mean.png|Meridional mean
File:Eddy geometry deformation streamfunction zonal mean.png|Zonal mean
File:Eddy geometry deformation streamfunction meridional std.png|Meridional STD
File:Eddy geometry deformation streamfunction zonal std.png|Zonal STD
&lt;/gallery>

As you might notice, streamfunction statistics captures quite a lot of the jet structure. For example, we right away see that there are three regions:
* Unstable jet: x from 0 to 30
* Transition: x from 30 to 40
* Wave maker: x from 40 to 60

This agrees with&lt;ref>http://www.stephaniewaterman.ca/Work/Documents/Presentations/2018/EnergyTransfers2018_Waterman.pdf , slide 20&lt;/ref>. Furthermore, most of the jet variance is centered in the middle meridionally, signaling the location of turbulent zone. It would be interesting to compare this statistics with other fields.

Also zonal mean likely tells us something about the direction of the flow: roughly below x=15, there are large recirculation gyres which dominate the flow and force it to go backward. On the other hand, right above x=15, these gyres stabilize a jet that forces the flow to go forward. In a sense, this is just conservation of momentum.

&lt;div style="background-color: antiquewhite; border-style: solid; margin: 10px; padding: 10px; display:inline-block">
'''Note''': For the task at hand, there are two important regions: region dominated by downgradient eddy fluxes and a region dominated by upgradient eddy fluxes. Also, region with largest streamfunction variance is interesting.
&lt;/div>

===Higher moments statistics===

If we want to, we could also analyze higher order statistics. For example, [[wikipedia:Skewness|skewness]] and [[wikipedia:Kurtosis|kurtosis]]. Roughly, we get higher moments by computing &lt;math>\mathbb{E}X^n&lt;/math>. For n=1, this is mean, for n=2, this is std, for n=3, this is skewness, for n=4, this is kurtosis, and so on.

If our distribution is Gaussian, then we should expect all moments larger than 2 to be zero. That is, Gaussian distribution can be completely described just by the mean and standard deviation. It might be interesting to look at the spatial distribution of higher moments as it will also tell if we actually have enough data to properly estimate standard deviation and mean.

Here is the code to compute higher moments:

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong) # load qq("@{i}") syntax

# compute mean psi field
psi_mean &lt;- readRDS("~/working/jet_stat_model_data/psi_mean.Rds")
psi_3_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
psi_4_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
psi_5_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
psi_6_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
psi_7_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])

for (i in 1:1000) {
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/@{i}.Rds"))
  psi_3_mean &lt;- psi_3_mean + (psi - psi_mean)^3
  psi_4_mean &lt;- psi_4_mean + (psi - psi_mean)^4
  psi_5_mean &lt;- psi_5_mean + (psi - psi_mean)^5
  psi_6_mean &lt;- psi_6_mean + (psi - psi_mean)^6
  psi_7_mean &lt;- psi_7_mean + (psi - psi_mean)^7
  print(i)
}
psi_3_mean &lt;- psi_3_mean / 1000
psi_4_mean &lt;- psi_4_mean / 1000
psi_5_mean &lt;- psi_5_mean / 1000
psi_6_mean &lt;- psi_6_mean / 1000
psi_7_mean &lt;- psi_7_mean / 1000

# save for later usage
saveRDS(psi_3_mean, "~/working/jet_stat_model_data/higher_moments/psi_3_mean.Rds")
saveRDS(psi_4_mean, "~/working/jet_stat_model_data/higher_moments/psi_4_mean.Rds")
saveRDS(psi_5_mean, "~/working/jet_stat_model_data/higher_moments/psi_5_mean.Rds")
saveRDS(psi_6_mean, "~/working/jet_stat_model_data/higher_moments/psi_6_mean.Rds")
saveRDS(psi_7_mean, "~/working/jet_stat_model_data/higher_moments/psi_7_mean.Rds")
&lt;/syntaxhighlight>
|Code to compute higher moments statistics of the streamfunction
}}

==Eddy Anisotropy==

Eddy anisotropy is a measure of deformation of eddies that is computed based on their statistics (in particular, it depends on the covariance of zonal and meridional velocities).

===Time mean eddy anisotropy===

One way to compute eddy anisotropy is by treating the mean as a time mean, for a fixed spatial location. Note that this approach might miss transient eddies (eddies that move around the flow in a periodic fashion). Also in Laure Zanna's paper, spatial averages are used. Hence, perhaps it makes more sense to use spatial means to compute eddy anisotropy as well?

Of course, for our model, both approaches might give the same result since the flow is in a statistically stable state.

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives

# compute eddy anisotropy L using time-mean
# note: did you know that this approach completely kills transient eddies? (i.e. eddies that travel around)
psi_mean &lt;- readRDS("~/working/jet_stat_model_data/psi_mean.Rds")

uu_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
vv_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
uv_mean &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
for (i in 1:1000) {
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/@{i}.Rds"))
  psi_dev &lt;- psi - psi_mean
  psi_dev_grad &lt;- gradient(psi_dev, 0.1)
  
  u_dev = -psi_dev_grad$Y
  v_dev = psi_dev_grad$X
  
  uu = u_dev^2
  vv = v_dev^2
  uv = u_dev*v_dev
  
  uu_mean &lt;- uu_mean + uu
  vv_mean &lt;- vv_mean + vv
  uv_mean &lt;- uv_mean + uv
  
  print(i)
}

uu_mean &lt;- uu_mean/1000
vv_mean &lt;- vv_mean/1000
uv_mean &lt;- uv_mean/1000

M &lt;- 1/2*(uu_mean - vv_mean)
N &lt;- uv_mean

L &lt;- sqrt(M^2 + N^2)

saveRDS(L, "~/working/jet_eddy_anisotropy_time_mean.Rds")
&lt;/syntaxhighlight>
|Code to compute time mean eddy anisotropy
}}

{{collapse|
&lt;syntaxhighlight lang="R">
L &lt;- readRDS("~/working/jet_eddy_anisotropy_time_mean.Rds")

# plot
png(file="eddy_anisotropy_time_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(L,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Time mean eddy anisotropy")
dev.off()

png(file="eddy_anisotropy_time_mean_meridional_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(L),
     xlab="y",
     ylab="Averaged meridional time mean eddy anisotropy")
dev.off()

png(file="eddy_anisotropy_time_mean_zonal_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(L),
     xlab="x",
     ylab="Averaged zonal time mean eddy anisotropy")
dev.off()
&lt;/syntaxhighlight>
|Code to plot time mean eddy anisotropy
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy anisotropy time mean.png|Time mean eddy anisotropy
File:Eddy geometry deformation eddy anisotropy time mean meridional mean.png|Meridional mean
File:Eddy geometry deformation eddy anisotropy time mean zonal mean.png|Zonal mean
&lt;/gallery>

===Spatial mean eddy anisotropy===

To be more in spirit with the Laure Zanna's article, we probably should compute eddy anisotropy using spatial means.

Here we use a Gaussian kernel to compute the means, with standard deviation &lt;math>\sigma=5&lt;/math>, that is equivalent to 20 km. In general, one &lt;math>\sigma&lt;/math> (or cell size in the model) equals 4 km.

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

# probably should be between 1 and 20
spatial_averaging_scale = 5

# compute eddy anisotropy L using spatial mean (instantaneous)
psi &lt;- readRDS("~/working/jet_time_model_data/10.Rds")
psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)

psi_dev &lt;- psi - psi_mean
psi_dev_grad &lt;- gradient(psi_dev, 0.1)
u_dev &lt;- -psi_dev_grad$Y
v_dev &lt;- psi_dev_grad$X
uu &lt;- u_dev^2
vv &lt;- v_dev^2
uv &lt;- u_dev*v_dev

uu_mean &lt;- convolution2D(uu, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
vv_mean &lt;- convolution2D(vv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
uv_mean &lt;- convolution2D(uv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)

M &lt;- 1/2*(uu_mean - vv_mean)
N &lt;- uv_mean

L &lt;- sqrt(M^2 + N^2)

saveRDS(L, "~/working/jet_eddy_anisotropy_spatial_mean.Rds")
&lt;/syntaxhighlight>
|Code to compute spatial mean eddy anisotropy
}}

We can then plot this:

Note: Computing averages introduces artifacts near the borders of the flow, where there's not enough data to compute averages. Lucky, in R there is a special placeholder for such cases - NA.

{{collapse|
&lt;syntaxhighlight lang="R">
L &lt;- readRDS("~/working/jet_eddy_anisotropy_spatial_mean.Rds")

# plot
png(file="eddy_anisotropy_spatial_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(L,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Spatial mean eddy anisotropy")
dev.off()

png(file="eddy_anisotropy_spatial_mean_meridional_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(L, na.rm=TRUE),
     xlab="y",
     ylab="Averaged meridional spatial mean eddy anisotropy")
dev.off()

png(file="eddy_anisotropy_spatial_mean_zonal_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(L, na.rm=TRUE),
     xlab="x",
     ylab="Averaged zonal spatial mean eddy anisotropy")
dev.off()
&lt;/syntaxhighlight>
|Code to plot spatial mean eddy anisotropy
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy anisotropy spatial mean.png|Spatial mean eddy anisotropy 
File:Eddy geometry deformation eddy anisotropy spatial mean meridional mean.png|Meridional mean
File:Eddy geometry deformation eddy anisotropy spatial mean zonal mean.png|Zonal mean
&lt;/gallery>

&lt;div style="background-color: plum; border-style: solid; margin: 10px; padding: 10px; display:inline-block">
TODO: Can we have a movie of spatial-mean eddy anisotropy? Also can study the time-statistics.
&lt;/div>

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

# probably should be between 1 and 20
spatial_averaging_scale = 5

compute_eddy_anosptropy_L_spatial_mean_at &lt;- function(i) {
  # compute eddy anisotropy L using spatial mean (instantaneous)
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/@{i}.Rds"))
  psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  
  psi_dev &lt;- psi - psi_mean
  psi_dev_grad &lt;- gradient(psi_dev, 0.1)
  u_dev &lt;- -psi_dev_grad$Y
  v_dev &lt;- psi_dev_grad$X
  uu &lt;- u_dev^2
  vv &lt;- v_dev^2
  uv &lt;- u_dev*v_dev
  
  uu_mean &lt;- convolution2D(uu, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  vv_mean &lt;- convolution2D(vv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  uv_mean &lt;- convolution2D(uv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  
  M &lt;- 1/2*(uu_mean - vv_mean)
  N &lt;- uv_mean
  
  L &lt;- sqrt(M^2 + N^2)

  L
}

for (i in 1:1000) {
  L &lt;- compute_eddy_anosptropy_L_spatial_mean_at(i)
  saveRDS(L, qq("~/working/time_series/jet_eddy_anisotropy_spatial_mean/@{i}.Rds"))
  print(i)
}
&lt;/syntaxhighlight>
|Code to compute time series of spatial mean eddy anisotropy
}}

{{collapse|
&lt;syntaxhighlight lang="R">
source("~/working/reusable_functions/compute_mean_and_std.R")
compute_mean_and_std("~/working/time_series/jet_eddy_anisotropy_spatial_mean",
                     "~/working/time_series_stat/jet_eddy_anisotropy_spatial_mean",
                     1000)
&lt;/syntaxhighlight>
|Code to compute mean and std
}}

{{collapse|
&lt;syntaxhighlight lang="R">
source("~/working/reusable_functions/plot_mean_and_std.R")
plot_mean_and_std("~/working/time_series_stat/jet_eddy_anisotropy_spatial_mean")
&lt;/syntaxhighlight>
|Code to plot mean and std
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy anisotropy spatial mean time stat mean.png|Mean
File:Eddy geometry deformation eddy anisotropy spatial mean time stat std.png|STD
File:Eddy geometry deformation eddy anisotropy spatial mean time stat meridional mean.png|Meridional mean
File:Eddy geometry deformation eddy anisotropy spatial mean time stat zonal mean.png|Zonal mean
File:Eddy geometry deformation eddy anisotropy spatial mean time stat meridional std.png|Meridional STD
File:Eddy geometry deformation eddy anisotropy spatial mean time stat zonal std.png|Zonal STD
&lt;/gallery>

==Product of large-scale deformation and vorticity==

===Time mean===

Time mean = time average = time large-scale field

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives

psi &lt;- readRDS("~/working/jet_stat_model_data/psi_mean.Rds")

psi_grad &lt;- gradient(psi, 0.1)
u &lt;- -psi_grad$Y
v &lt;- psi_grad$X

u_grad &lt;- gradient(u, 0.1)
v_grad &lt;- gradient(v, 0.1)

D &lt;- u_grad$Y + v_grad$X
D_T &lt;- u_grad$X - v_grad$Y

delta &lt;- sqrt(D^2 + D_T^2)
vorticity &lt;- v_grad$X - u_grad$Y;

vort_def_prod &lt;- abs(vorticity)*delta

saveRDS(vort_def_prod, "~/working/jet_vort_def_prod_time_mean.Rds")
&lt;/syntaxhighlight>
|Code to compute product of vorticity and deformation for time large-scale field
}}

{{collapse|
&lt;syntaxhighlight lang="R">
vort_def_prod &lt;- readRDS("~/working/jet_vort_def_prod_time_mean.Rds")

# plot
png(file="jet_vort_def_prod_time_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(vort_def_prod,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Time mean product of vorticity and deformation")
dev.off()

png(file="jet_vort_def_prod_time_mean_meridional_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(vort_def_prod, na.rm=TRUE),
     xlab="y",
     ylab="",
     main="Averaged meridional time mean product of vorticity and deformation")
dev.off()

png(file="jet_vort_def_prod_time_mean_zonal_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(vort_def_prod, na.rm=TRUE),
     xlab="x",
     ylab="",
     main="Averaged zonal time mean product of vorticity and deformation")
dev.off()
&lt;/syntaxhighlight>
|Code to plot product of vorticity and deformation for time large-scale field
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation jet vort def prod time mean.png|Time mean product of vorticity and deformation
File:Eddy geometry deformation jet vort def prod time mean meridional mean.png|Meridional mean
File:Eddy geometry deformation jet vort def prod time mean zonal mean.png|Zonal mean
&lt;/gallery>

===Spatial mean===

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

# probably should be between 1 and 20
spatial_averaging_scale = 5

# compute eddy anisotropy L using spatial mean (instantaneous)
psi &lt;- readRDS("~/working/jet_time_model_data/10.Rds")
psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
# psi_mean is large-scale streamfunction field
psi &lt;- psi_mean # we won't need small-scale field anymore

psi_grad &lt;- gradient(psi, 0.1)
u &lt;- -psi_grad$Y
v &lt;- psi_grad$X

u_grad &lt;- gradient(u, 0.1)
v_grad &lt;- gradient(v, 0.1)

D &lt;- u_grad$Y + v_grad$X
D_T &lt;- u_grad$X - v_grad$Y

delta &lt;- sqrt(D^2 + D_T^2)
vorticity &lt;- v_grad$X - u_grad$Y;

vort_def_prod &lt;- abs(vorticity)*delta

saveRDS(vort_def_prod, "~/working/jet_vort_def_prod_spatial_mean.Rds")
&lt;/syntaxhighlight>
|Code to compute product of vorticity and deformation for spatial large-scale field
}}

{{collapse|
&lt;syntaxhighlight lang="R">
vort_def_prod &lt;- readRDS("~/working/jet_vort_def_prod_spatial_mean.Rds")

# plot
png(file="jet_vort_def_prod_spatial_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
imagep(vort_def_prod,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Spatial mean product of vorticity and deformation")
dev.off()

png(file="jet_vort_def_prod_spatial_mean_meridional_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((-400:400)*0.01*4,
     colMeans(vort_def_prod, na.rm=TRUE),
     xlab="y",
     ylab="",
     main="Averaged meridional spatial mean product of vorticity and deformation")
dev.off()

png(file="jet_vort_def_prod_spatial_mean_zonal_mean.png",
    width=480*2,
    height=480,
    pointsize=18)
plot((1:1501)*0.01*4,
     rowMeans(vort_def_prod, na.rm=TRUE),
     xlab="x",
     ylab="",
     main="Averaged zonal spatial mean product of vorticity and deformation")
dev.off()
&lt;/syntaxhighlight>
|Code to plot product of vorticity and deformation for spatial large-scale field
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation jet vort def prod spatial mean.png|Spatial mean product of vorticity and deformation
File:Eddy geometry deformation jet vort def prod spatial mean meridional mean.png|Meridional mean
File:Eddy geometry deformation jet vort def prod spatial mean zonal mean.png|Zonal mean
&lt;/gallery>

&lt;div style="background-color: plum; border-style: solid; margin: 10px; padding: 10px; display:inline-block">
Note: We can improve visibility of small-scale features by computing something like '(delta+0.2)*(abs(vorticity)+0.2)' instead of '(delta)*(abs(vorticity))'.
&lt;/div>

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

# probably should be between 1 and 20
spatial_averaging_scale = 5

compute_vorticity_deformation_product_at &lt;- function(i) {
  # compute eddy anisotropy L using spatial mean (instantaneous)
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/@{i}.Rds"))
  psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  # psi_mean is large-scale streamfunction field
  psi &lt;- psi_mean # we won't need small-scale field anymore
  
  psi_grad &lt;- gradient(psi, 0.1)
  u &lt;- -psi_grad$Y
  v &lt;- psi_grad$X
  
  u_grad &lt;- gradient(u, 0.1)
  v_grad &lt;- gradient(v, 0.1)
  
  D &lt;- u_grad$Y + v_grad$X
  D_T &lt;- u_grad$X - v_grad$Y
  
  delta &lt;- sqrt(D^2 + D_T^2)
  vorticity &lt;- v_grad$X - u_grad$Y;
  
  vort_def_prod &lt;- abs(vorticity)*delta

  vort_def_prod
}

for (i in 1:1000) {
  vort_def_prod &lt;- compute_vorticity_deformation_product_at(i)
  saveRDS(vort_def_prod, qq("~/working/time_series/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
  print(i)
}
&lt;/syntaxhighlight>
|Code to compute time series of product of vorticity and deformation for spatial large-scale field
}}

{{collapse|
&lt;syntaxhighlight lang="R">
source("~/working/reusable_functions/compute_mean_and_std.R")
compute_mean_and_std("~/working/time_series/vorticity_deformation_product_spatial_mean",
                     "~/working/time_series_stat/vorticity_deformation_product_spatial_mean",
                     1000)
&lt;/syntaxhighlight>
|Code to compute mean and std
}}

{{collapse|
&lt;syntaxhighlight lang="R">
source("~/working/reusable_functions/plot_mean_and_std.R")
plot_mean_and_std("~/working/time_series_stat/vorticity_deformation_product_spatial_mean")
&lt;/syntaxhighlight>
|Code to plot mean and std
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation jet vort def prod spatial mean time stat mean.png|Mean
File:Eddy geometry deformation jet vort def prod spatial mean time stat std.png|STD
File:Eddy geometry deformation jet vort def prod spatial mean time stat meridional mean.png|Meridional mean
File:Eddy geometry deformation jet vort def prod spatial mean time stat zonal mean.png|Zonal mean
File:Eddy geometry deformation jet vort def prod spatial mean time stat meridional std.png|Meridional STD
File:Eddy geometry deformation jet vort def prod spatial mean time stat zonal std.png|Zonal STD
&lt;/gallery>

==Comparing eddy anisotropy to deformation and vorticity product==

We now need to figure out which regions in the field we actually want to study. We also can just try the overall fields, but it might be a good idea to pick regions where we expect the parametrization to work well, and then fine-tune the details there. Only after that try to generalize it for the overall field (while also checking that things still make sense).

As we can see from above, time statistics of spatial eddy anisotropy and vorticity deformation product look quite similar except for some regions. In particular, they look different in the upstream region right at the center of the jet, and near the maximum of eddy kinetic energy. This is consistent with the presentation (see references).

Now, to figure out the best partition scale at a point, we should pick a point where both fields fit nicely, and try out different partitioning scales.

Also notice that the meridional profile of vorticity deformation parametrization is not as bulged near the gyres as the eddy anisotropy profile. This might suggest that those regions require different spatial scales (rather than the global one above which was set to about 20 km, or &lt;math>\sigma=5&lt;/math>). This might be the case because those gyres are much more local effect, so information about them is lost for such large partitioning scale.

Notice that time mean ''vorticity deformation'' and ''eddy anisotropy'' don't match as much as spatial mean ''vorticity deformation'' and ''eddy anisotropy'' do. Actually in the second case there seems to be a lot of similarity. But, as we have noticed from the average meridional slices, spatial partitioning scales are likely to be different for different places in the flow. We need to get this separation right. In the next section we will study dependence of similarity on spatial mean in further detail.

I actually think that image plots of mean and svd of these two fields look very similar (with account for position-depending partitioning scale and also upstream and max EKE regions where parametrization breaks).

===Comparing at a point===
{{collapse|
&lt;syntaxhighlight lang="R">
eddy_ani_std &lt;- readRDS("~/working/time_series_stat/jet_eddy_anisotropy_spatial_mean/std.Rds")
vort_def_std &lt;- readRDS("~/working/time_series_stat/vorticity_deformation_product_spatial_mean/std.Rds")

png(file="eddy_ani_std_sample_point.png",
    width=480*2,
    height=480,
    pointsize=18)

imagep(eddy_ani_std,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Eddy Anisotropy STD")
#points(350,300, col="red", pch=11)
points(350*0.01*4,(300-400)*0.01*4, col="red", pch=11)

dev.off()

png(file="vort_def_std_sample_point.png",
    width=480*2,
    height=480,
    pointsize=18)

#imagep(vort_def_std)
imagep(vort_def_std,
       decimate = FALSE,
       x=(1:1501)*0.01*4,
       y=(-400:401)*0.01*4,
       ylab="y",
       xlab="x",
       useRaster = TRUE, # prevents white line glitch
       main="Vorticity Deformation STD")
points(350*0.01*4,(300-400)*0.01*4, col="red", pch=11)

dev.off()
&lt;/syntaxhighlight>
|Code to plot the point on top of svd plots of vorticity deformation and eddy anisotropy
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy ani std sample point.png|Chosen point plotted on top of eddy anisotropy STD field
File:Eddy geometry deformation vort def std sample point.png|Chosen point plotted on top of vorticity deformation STD field
&lt;/gallery>

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(spatialfil) # Gaussian kernel

plot_averaging_function_at_a_point &lt;- function(spatial_averaging_scale) {
  point &lt;- c(350,300)
  #spatial_averaging_scale &lt;- 30 #5
  
  averaging_function &lt;- matrix(0L, nrow = dim(psi_mean)[1], ncol = dim(psi_mean)[2])
  kernel &lt;- convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix
  
  from_x &lt;- -floor(dim(kernel)[1]/2) + point[1]+1
  to_x &lt;- dim(kernel)[1] - floor(dim(kernel)[1]/2) + point[1]
  
  from_y &lt;- -floor(dim(kernel)[2]/2) + point[2]+1
  to_y &lt;- dim(kernel)[2] - floor(dim(kernel)[2]/2) + point[2]
  
  averaging_function[from_x:to_x,from_y:to_y] &lt;- kernel
  
  
  # plot
  png(file=qq("averaging_function_@{spatial_averaging_scale}.png"),
      width=480*2,
      height=480,
      pointsize=18)
  imagep(averaging_function,
         decimate = FALSE,
         x=(1:1501)*0.01*4,
         y=(-400:401)*0.01*4,
         ylab="y",
         xlab="x",
         useRaster = TRUE, # prevents white line glitch
         main=qq("Averaging function for spatial scale of @{spatial_averaging_scale}"))
  # add contour
  contour(1:dim(vort_def_std)[1]*0.01*4, (1:dim(vort_def_std)[2]-400)*0.01*4, vort_def_std, add=TRUE)
  dev.off()
}

plot_averaging_function_at_a_point(5)
plot_averaging_function_at_a_point(20)
plot_averaging_function_at_a_point(30)
&lt;/syntaxhighlight>
|Code to plot the averaging function at a point as a function of partitioning scale. SVD of vorticity deformation field is overlaid on top.
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation averaging function 30.png|30
File:Eddy geometry deformation averaging function 20.png|20
File:Eddy geometry deformation averaging function 5.png|5
&lt;/gallery>

Judging from spatial structure of vorticity SVD, optimal partitioning scale for this point should be somewhere between 5 and 20, and definitely not much larger than 20.

Now, lets compute both fields for one time-step of the field:

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

compute_vorticity_deformation_product_for_spatial_averaging_scale &lt;- function(spatial_averaging_scale) {
  # compute eddy anisotropy L using spatial mean (instantaneous)
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/1.Rds"))
  psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  # psi_mean is large-scale streamfunction field
  psi &lt;- psi_mean # we won't need small-scale field anymore
  
  psi_grad &lt;- gradient(psi, 0.1)
  u &lt;- -psi_grad$Y
  v &lt;- psi_grad$X
  
  u_grad &lt;- gradient(u, 0.1)
  v_grad &lt;- gradient(v, 0.1)
  
  D &lt;- u_grad$Y + v_grad$X
  D_T &lt;- u_grad$X - v_grad$Y
  
  delta &lt;- sqrt(D^2 + D_T^2)
  vorticity &lt;- v_grad$X - u_grad$Y;
  
  vort_def_prod &lt;- abs(vorticity)*delta
  
  vort_def_prod
}

for (i in 1:30) {
  vort_def_prod &lt;- compute_vorticity_deformation_product_for_spatial_averaging_scale(i)
  saveRDS(vort_def_prod, qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
  print(i)
}
&lt;/syntaxhighlight>
|Code to compute vorticity deformation product at a time step for a number of different partitioning scales
}}

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)
library(pracma) # To compute derivatives
library(spatialfil) # Gaussian kernel
library(imagine) # Convolution

compute_eddy_anisotropy_for_spatial_averaging_scale &lt;- function(spatial_averaging_scale) {
  # compute eddy anisotropy L using spatial mean (instantaneous)
  psi &lt;- readRDS(qq("~/working/jet_time_model_data/1.Rds"))
  psi_mean &lt;- convolution2D(psi, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  
  psi_dev &lt;- psi - psi_mean
  psi_dev_grad &lt;- gradient(psi_dev, 0.1)
  u_dev &lt;- -psi_dev_grad$Y
  v_dev &lt;- psi_dev_grad$X
  uu &lt;- u_dev^2
  vv &lt;- v_dev^2
  uv &lt;- u_dev*v_dev
  
  uu_mean &lt;- convolution2D(uu, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  vv_mean &lt;- convolution2D(vv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  uv_mean &lt;- convolution2D(uv, convKernel(sigma = spatial_averaging_scale, k = 'gaussian')$matrix)
  
  M &lt;- 1/2*(uu_mean - vv_mean)
  N &lt;- uv_mean
  
  L &lt;- sqrt(M^2 + N^2)
  
  L
}

for (i in 1:30) {
  L &lt;- compute_eddy_anisotropy_for_spatial_averaging_scale(i)
  saveRDS(L, qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
  print(i)
}
&lt;/syntaxhighlight>
|Code to eddy anisotropy at a time step for a number of different partitioning scales
}}

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

vort_def_prod1 &lt;- readRDS("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/1.Rds")
eddy_anisotropy1 &lt;- readRDS("~/working/spatial_scales/eddy_anisotropy_spatial_mean/1.Rds")

vort_def_prod2 &lt;- readRDS("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/2.Rds")
eddy_anisotropy2 &lt;- readRDS("~/working/spatial_scales/eddy_anisotropy_spatial_mean/2.Rds")

vort_def_prod5 &lt;- readRDS("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/5.Rds")
eddy_anisotropy5 &lt;- readRDS("~/working/spatial_scales/eddy_anisotropy_spatial_mean/5.Rds")

vort_def_prod10 &lt;- readRDS("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/10.Rds")
eddy_anisotropy10 &lt;- readRDS("~/working/spatial_scales/eddy_anisotropy_spatial_mean/10.Rds")

plot_field &lt;- function(field, name) {
  imagep(field,
         decimate = FALSE,
         x=(1:1501)*0.01*4,
         y=(-400:401)*0.01*4,
         ylab="y",
         xlab="x",
         useRaster = TRUE, # prevents white line glitch
         main=name)
}

# plot
png(file="vort_def_eddy_anisotropy_side_by_side_different_partitioning scales.png",
    width=480*4,
    height=480*2,
    pointsize=18)
par(mfrow=c(2,4))
  plot_field(vort_def_prod1, "Vorticity Deformation 1")
  plot_field(vort_def_prod2, "Vorticity Deformation 2")
  plot_field(vort_def_prod5, "Vorticity Deformation 5")
  plot_field(vort_def_prod10, "Vorticity Deformation 10")
  
  plot_field(eddy_anisotropy1, "Eddy Anisotropy 1")
  plot_field(eddy_anisotropy2, "Eddy Anisotropy 2")
  plot_field(eddy_anisotropy5, "Eddy Anisotropy 5")
  plot_field(eddy_anisotropy10, "Eddy Anisotropy 10")
dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy and vorticity deformation side by side for several partitioning scales
}}

Notice that some features match better on some specific partitioning scales:

[[File:Eddy geometry deformation vort def eddy anisotropy side by side different partitioning scales.png|800px]]

===Local patch===

So, here is the idea. We don't just compare at a point, but instead we compare at a patch of points near that point. Physically, we should expect things to be smooth, so partitioning scale and eddy mixing rate parameters should be similar the closer we are to the center of the patch.


{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

i = 1

# c(350,300)
# c(350,400)
origin = c(400,400)

#points = list(
  #c(350,304), c(351,304), c(352,304), c(353,304), c(354,304),
  #c(350,303), c(351,303), c(352,303), c(353,303), c(354,303),
  #c(350,302), c(351,302), c(352,302), c(353,302), c(354,302),
  #c(350,301), c(351,301), c(352,301), c(353,301), c(354,301),
  #c(350,300), c(351,300), c(352,300), c(353,300), c(354,300)
  #)

png(file="both_fields_in_a_sampling_zone_as_a_function_of_partitioning_scale.png",
    width=480*2,
    height=480,
    pointsize=18)

  plot(c(0), xlim=c(0,30), ylim=c(0,0.04),
       main="Characteristics of fields for different partitioning scales",
       ylab="Vorticity Deformation/Eddy Anisotropy",
       xlab="Partitioning scale")
  legend("topright", legend=c("Vorticity Deformation", "Eddy Anisotropy"),
         col=c("red", "blue"), pch=1, cex=0.8)

  for (dx in -5:5) {
    for (dy in -5:5) {
      point = c(origin[1]+dx,origin[2]+dy)
      
      vort_def_prod_vector &lt;- c()
      vort_def_prod_vector_x &lt;- c()
      eddy_anisotropy_vector &lt;- c()
      eddy_anisotropy_vector_x &lt;- c()
      
      samples = c((1:(5*4))/4, 1:30)
      
      for (i in samples) {
        vort_def_prod &lt;- readRDS(qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
        eddy_anisotropy &lt;- readRDS(qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
        
        vort_def_prod_vector &lt;- c(vort_def_prod_vector, vort_def_prod[point[1],point[2]])
        vort_def_prod_vector_x &lt;- c(vort_def_prod_vector_x, i)
        eddy_anisotropy_vector &lt;- c(eddy_anisotropy_vector, eddy_anisotropy[point[1],point[2]])
        eddy_anisotropy_vector_x &lt;- c(eddy_anisotropy_vector_x, i)
        print(i)
      }
      
      points(vort_def_prod_vector_x, vort_def_prod_vector, ylim=c(0,0.03), col="red")
      points(eddy_anisotropy_vector_x, eddy_anisotropy_vector, col="blue")
    }
  }
dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy and vorticity deformation vs partitioning scale
}}

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

i = 1

# c(350,300)
# c(350,400)
origin = c(400,400)

#plot(c(0), xlim=c(0,30), ylim=c(0,0.04))

get_parametrization_for &lt;- function(partitioning_scale) {
  i &lt;- partitioning_scale
  vort_def_prod_vector &lt;- c()
  eddy_anisotropy_vector &lt;- c()
  
  eddy_anisotropy_list &lt;- c()
  for (dx in -5:5) {
    for (dy in -5:5) {
      point = c(origin[1]+dx,origin[2]+dy)
      vort_def_prod &lt;- readRDS(qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
      eddy_anisotropy &lt;- readRDS(qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
      
      vort_def_prod_vector &lt;- c(vort_def_prod_vector, vort_def_prod[point[1],point[2]])
      eddy_anisotropy_vector &lt;- c(eddy_anisotropy_vector, eddy_anisotropy[point[1],point[2]])
      
      #points(vort_def_prod_vector_x, vort_def_prod_vector, ylim=c(0,0.03))
      #points(eddy_anisotropy_vector_x, eddy_anisotropy_vector)
    }
    print(dx)
  }
  
  list(vort_def_prod_vector, eddy_anisotropy_vector)
}

png(file="eddy_ani_as_function_of_vort_def_linear_several_partitioning_scales.png",
    width=480*2,
    height=480,
    pointsize=18)

parametrization &lt;- get_parametrization_for(7)
plot((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     xlim=c(0,1), ylim=c(0,1), col='red',
     xlab="Vorticity Deformation",
     ylab="Eddy Anisotropy",
     main="Vorticity Deformation as a function of Eddy Anisotropy")
legend("bottomright", legend=c("7", "8", "9", "10", "11", "12", "13"),
       col=c("red", "green", "blue", "black", "red", "green", "blue"),
       pch=c(    1,       1,      1,       1,     3,       3,      3), cex=0.8)


parametrization &lt;- get_parametrization_for(8)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     col='green')

parametrization &lt;- get_parametrization_for(9)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue')

parametrization &lt;- get_parametrization_for(10)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='black')

parametrization &lt;- get_parametrization_for(11)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='red', pch=3)

parametrization &lt;- get_parametrization_for(12)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='green', pch=3)

parametrization &lt;- get_parametrization_for(13)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue', pch=3)
dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy vs vorticity deformation for different partitioning scales that seem to make things correlate well.
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy ani as function of vort def linear several partitioning scales.png|Eddy anisotropy vs vorticity deformation for several different partitioning scales
File:Eddy geometry deformation both fields in a sampling zone as a function of partitioning scale.png|Eddy anisotropy and vorticity deformation vs several different partitioning scales
&lt;/gallery>

From the plots, we can see that in this patch, optimal partitioning scale is somewhere around 10 and 11 since then the relationship between the fields is linear, as parametrization predicts.

It should also be noted that for smaller partitioning scales there is no correlation at all:


{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

i = 1

# c(350,300)
# c(350,400)
origin = c(400,400)

#plot(c(0), xlim=c(0,30), ylim=c(0,0.04))

get_parametrization_for &lt;- function(partitioning_scale) {
  i &lt;- partitioning_scale
  vort_def_prod_vector &lt;- c()
  eddy_anisotropy_vector &lt;- c()
  
  eddy_anisotropy_list &lt;- c()
  for (dx in -5:5) {
    for (dy in -5:5) {
      point = c(origin[1]+dx,origin[2]+dy)
      vort_def_prod &lt;- readRDS(qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
      eddy_anisotropy &lt;- readRDS(qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
      
      vort_def_prod_vector &lt;- c(vort_def_prod_vector, vort_def_prod[point[1],point[2]])
      eddy_anisotropy_vector &lt;- c(eddy_anisotropy_vector, eddy_anisotropy[point[1],point[2]])
      
      #points(vort_def_prod_vector_x, vort_def_prod_vector, ylim=c(0,0.03))
      #points(eddy_anisotropy_vector_x, eddy_anisotropy_vector)
    }
    print(dx)
  }
  
  list(vort_def_prod_vector, eddy_anisotropy_vector)
}

png(file="eddy_ani_as_function_of_vort_def_linear_several_partitioning_scales_small_scales.png",
    width=480*2,
    height=480,
    pointsize=18)

parametrization &lt;- get_parametrization_for(1)
plot((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     xlim=c(0,1), ylim=c(0,1), col='red',
     xlab="Vorticity Deformation",
     ylab="Eddy Anisotropy",
     main="Vorticity Deformation as a function of Eddy Anisotropy")
legend("bottomright", legend=c("1", "2", "3", "4", "5", "6", "7"),
       col=c("red", "green", "blue", "black", "red", "green", "blue"),
       pch=c(    1,       1,      1,       1,     3,       3,      3), cex=0.8)


parametrization &lt;- get_parametrization_for(2)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     col='green')

parametrization &lt;- get_parametrization_for(3)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue')

parametrization &lt;- get_parametrization_for(4)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='black')

parametrization &lt;- get_parametrization_for(5)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='red', pch=3)

parametrization &lt;- get_parametrization_for(6)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='green', pch=3)

parametrization &lt;- get_parametrization_for(7)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue', pch=3)
dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy and vorticity deformation vs partitioning scale for smaller partitioning scales.
}}


&lt;gallery mode="packed">
File:Eddy geometry deformation eddy ani as function of vort def linear several partitioning scales small scales.png|Eddy anisotropy vs vorticity deformation for several different partitioning scales (small scales)
&lt;/gallery>

Alright, we can still start seeing some non-linear correlation starting from around 6-7. But there is definitely no correlation for smaller scales.

Now, where does this coherent striped noise come from, even for partitioning scales of 10 and 11? My guess would be that the further we are from the center of the patch, the larger the discrepancy will be between optimal partitioning scale (and eddy mixing rate) for the central point and points away from the central point of the patch.

We could test this by coloring the points by their distance from the central point of the patch:

TODO

Alternatively, we could first identify how far from the single coherent line these points are, and then plot them in the field domain:

TODO

Objection: Wait, I find this suspicious. Think about it. Our patch is 11x11. And optimal partitioning scale is around 11. This seems awfully suspicious. To make things less biased, we should probably select a smaller patch for smaller partitioning scales (and larger one for larger partitioning scales).

Ok, a quick way to get rid of this possible bias is to make sampling region dimensions proportional to partitioning scales. For example, we can set the side length of sampling region to be equal to the partitioning scale (which equals the standard deviation of partitioning Gaussian kernel).

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

i = 1

# c(350,300)
# c(350,400)
origin = c(400,400)

#plot(c(0), xlim=c(0,30), ylim=c(0,0.04))

get_parametrization_for &lt;- function(partitioning_scale) {
  i &lt;- partitioning_scale
  vort_def_prod_vector &lt;- c()
  eddy_anisotropy_vector &lt;- c()
  
  eddy_anisotropy_list &lt;- c()
  for (dx in -partitioning_scale:partitioning_scale) {
    for (dy in -partitioning_scale:partitioning_scale) {
      point = c(origin[1]+dx,origin[2]+dy)
      vort_def_prod &lt;- readRDS(qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
      eddy_anisotropy &lt;- readRDS(qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
      
      vort_def_prod_vector &lt;- c(vort_def_prod_vector, vort_def_prod[point[1],point[2]])
      eddy_anisotropy_vector &lt;- c(eddy_anisotropy_vector, eddy_anisotropy[point[1],point[2]])
      
      #points(vort_def_prod_vector_x, vort_def_prod_vector, ylim=c(0,0.03))
      #points(eddy_anisotropy_vector_x, eddy_anisotropy_vector)
    }
    print(dx)
  }
  
  list(vort_def_prod_vector, eddy_anisotropy_vector)
}

#png(file="eddy_ani_as_function_of_vort_def_linear_several_partitioning_scales_small_scales.png",
    #width=480*2,
    #height=480,
    #pointsize=18)

parametrization &lt;- get_parametrization_for(1)
plot((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     xlim=c(0,1), ylim=c(0,1), col='red',
     xlab="Vorticity Deformation",
     ylab="Eddy Anisotropy",
     main="Vorticity Deformation as a function of Eddy Anisotropy")
legend("bottomright", legend=c("1", "2", "3", "4", "5", "6", "7"),
       col=c("red", "green", "blue", "black", "red", "green", "blue"),
       pch=c(    1,       1,      1,       1,     3,       3,      3), cex=0.8)


parametrization &lt;- get_parametrization_for(2)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     col='green')

parametrization &lt;- get_parametrization_for(3)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue')

parametrization &lt;- get_parametrization_for(4)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='black')

parametrization &lt;- get_parametrization_for(5)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='red', pch=3)

parametrization &lt;- get_parametrization_for(6)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='green', pch=3)

parametrization &lt;- get_parametrization_for(7)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue', pch=3)
#dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy and vorticity deformation vs partitioning scale for smaller partitioning scales. Debiased version with sampling region proportional to partitioning scale.
}}

{{collapse|
&lt;syntaxhighlight lang="R">
library(GetoptLong)

i = 1

# c(350,300)
# c(350,400)
origin = c(400,400)

#plot(c(0), xlim=c(0,30), ylim=c(0,0.04))

get_parametrization_for &lt;- function(partitioning_scale) {
  i &lt;- partitioning_scale
  vort_def_prod_vector &lt;- c()
  eddy_anisotropy_vector &lt;- c()
  
  eddy_anisotropy_list &lt;- c()
  for (dx in -partitioning_scale:partitioning_scale) {
    for (dy in -partitioning_scale:partitioning_scale) {
      point = c(origin[1]+dx,origin[2]+dy)
      vort_def_prod &lt;- readRDS(qq("~/working/spatial_scales/vorticity_deformation_product_spatial_mean/@{i}.Rds"))
      eddy_anisotropy &lt;- readRDS(qq("~/working/spatial_scales/eddy_anisotropy_spatial_mean/@{i}.Rds"))
      
      vort_def_prod_vector &lt;- c(vort_def_prod_vector, vort_def_prod[point[1],point[2]])
      eddy_anisotropy_vector &lt;- c(eddy_anisotropy_vector, eddy_anisotropy[point[1],point[2]])
      
      #points(vort_def_prod_vector_x, vort_def_prod_vector, ylim=c(0,0.03))
      #points(eddy_anisotropy_vector_x, eddy_anisotropy_vector)
    }
    print(dx)
  }
  
  list(vort_def_prod_vector, eddy_anisotropy_vector)
}

png(file="eddy_ani_as_function_of_vort_def_linear_several_partitioning_scales_debiased.png",
    width=480*2,
    height=480,
    pointsize=18)

parametrization &lt;- get_parametrization_for(7)
plot((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     xlim=c(0,1), ylim=c(0,1), col='red',
     xlab="Vorticity Deformation",
     ylab="Eddy Anisotropy",
     main="Vorticity Deformation as a function of Eddy Anisotropy")
legend("bottomright", legend=c("7", "8", "9", "10", "11", "12", "13"),
       col=c("red", "green", "blue", "black", "red", "green", "blue"),
       pch=c(    1,       1,      1,       1,     3,       3,      3), cex=0.8)


parametrization &lt;- get_parametrization_for(8)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
       (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
     (unlist(parametrization[2])-min(unlist(parametrization[2])))/
       (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
     col='green')

parametrization &lt;- get_parametrization_for(9)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue')

parametrization &lt;- get_parametrization_for(10)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='black')

parametrization &lt;- get_parametrization_for(11)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='red', pch=3)

parametrization &lt;- get_parametrization_for(12)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='green', pch=3)

parametrization &lt;- get_parametrization_for(13)
points((unlist(parametrization[1])-min(unlist(parametrization[1])))/
         (max(unlist(parametrization[1]))-min(unlist(parametrization[1]))),
       (unlist(parametrization[2])-min(unlist(parametrization[2])))/
         (max(unlist(parametrization[2])-min(unlist(parametrization[2])))),
       col='blue', pch=3)
dev.off()
&lt;/syntaxhighlight>
|Code to plot eddy anisotropy and vorticity deformation vs partitioning scale for larger partitioning scales. Debiased version with sampling region proportional to partitioning scale.
}}

&lt;gallery mode="packed">
File:Eddy geometry deformation eddy ani as function of vort def linear several partitioning scales small scales debiased.png|Eddy anisotropy and vorticity deformation vs several different partitioning scales (small scales, debiased)
File:Eddy geometry deformation eddy ani as function of vort def linear several partitioning scales debiased.png|Eddy anisotropy and vorticity deformation vs several different partitioning scales (large scales, debiased)
&lt;/gallery>

As we can see from the plots above, we get similar results when accounted for a possible bias that could come from the size of sampling patch.

And we also see again that the relationship between the fields is most linear when partitioning scale is about 10. Let's study this case in detail, and also let's color the points by distance from the center of the sampling patch. I would expect that the points that are furthest from the center perform the worse.

TODO: have a weighted correlation?

TODO: figure out where squiggly lines come from

TODO: add a spatial picture of plots above. I.e. plot the actual field instead of just scatter plot. We should be able to visually confirm that fields start looking more and more similar for the optimal partitioning scale.

TODO: eddy mixing rate should be a function of partition scale. So we can group all patches with the same partition scale together to do a generic fit. A benefit of this is that errors will probably be more gaussian in this case.

==TODO==

FIGURE 1
[L for fully resolved flow with streamfunction (mean and instantaneous) superimposed]
Figure 1: The eddy anisotropy of the idealized WBC that is the target of the parameterization based on the large-scale flow deformation.

FIGURE 2
[4x3 panel showing KE?; deformation?; parameterized L; some metric of match to eddy L/required mixing rate? for sigma = 20, 40 and 200 km]
Figure 2: Character of the large-scale flow and its performance in predicting the eddy anisotropy via the deformation-based parameterization as a function of the partition scale.

FIGURE 3
[Diagnostics of KE? deformation? In large vs small scale  flow as a function of partition scale on the x-axis in efforts to argue there is no obvious choice for the partition scale]
-- Maybe show that at different scales, different features are parametrized better?

FIGURE 4
[Mean optimal sigma and mixing rate from 998 iterations if both are allowed to vary spatially; paramterized L from optimal fit and mean(relative error)]
TO DO: Get mean &amp; stds of 998 fits from Danil

FIGURE 5
[More analysis of performance of the parameterization: scatter plot showing actual L on x, parameterized L on y coloured by mixing rate? partition scale?]
TO DO: Get mean &amp; stds of 998 fits from Danil

FIGURE 6?
[Something speculative about how to ‚Äúguess‚Äù the sigma from diagnoses of eddy size: show EKE is not a good predictor but loop calculation can capture some gross features like minimia in size on flanks of jet and enhancement at EKE maximum?; show best fit separation scale vs eddy size as field plots?  Scaltter plots?


* It seems that field is not zoomed in on the region of interest (as in for example, &lt;ref>https://ams.confex.com/ams/22FLUID/meetingapp.cgi/Paper/360110&lt;/ref>). Need to re-scale so that the things are consistent. But it's good that we have the sponge regions since that allows us to do convolutions more easily.

[[Category:Mesoscale ocean eddies]]
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Template used on this page:
</p></div><ul>
<li><a href="https://wiki.nya.pink/wiki/Template:Collapse" title="Template:Collapse">Template:Collapse</a> (<a href="https://wiki.nya.pink/index.php?title=Template:Collapse&amp;action=edit" title="Template:Collapse">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html" title="Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields">Research:Evaluating deformation-based paramatrization of ocean mesoscale eddies using eddy geometry approach/Overview of relevant fields</a>.</p>
</div>
		
		<div class="printfooter">Retrieved from "<a dir="ltr" href="wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html">https://wiki.nya.pink/wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields</a>"</div>
		
		<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>
		<div class="visualClear"></div>
		
	</div>
</div>


		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://wiki.nya.pink/index.php?title=Special:UserLogin&amp;returnto=Research%3AEvaluating+deformation-based+paramatrization+of+ocean+mesoscale+eddies+using+eddy+geometry+approach%2FOverview+of+relevant+fields&amp;returntoquery=action%3Dedit" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://wiki.nya.pink/index.php?title=Talk:Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<ul class="menu">
													</ul>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible"><span><a href="wiki/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html">Read</a></span></li><li id="ca-viewsource" class="collapsible selected"><span><a href="./index.php%3Ftitle=Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;action=edit.html" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="./index.php%3Ftitle=Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;action=history.html" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<ul class="menu">
													</ul>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://wiki.nya.pink/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Lab Journal Wiki" title="Search Lab Journal Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="robots.txt.html" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage-description"><a href="robots.txt.html" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-recentchanges"><a href="https://wiki.nya.pink/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="wiki/Special:Random.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help-mediawiki"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents">Help about MediaWiki</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="wiki/Special:WhatLinksHere/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="https://wiki.nya.pink/wiki/Special:RecentChangesLinked/Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach/Overview_of_relevant_fields" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="wiki/Special:SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-info"><a href="./index.php%3Ftitle=Research:Evaluating_deformation-based_paramatrization_of_ocean_mesoscale_eddies_using_eddy_geometry_approach%252FOverview_of_relevant_fields&amp;action=info.html" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="https://wiki.nya.pink/wiki/Lab_Journal_Wiki:Privacy_policy" title="Lab Journal Wiki:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="https://wiki.nya.pink/wiki/Lab_Journal_Wiki:About" title="Lab Journal Wiki:About">About Lab Journal Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="https://wiki.nya.pink/wiki/Lab_Journal_Wiki:General_disclaimer" title="Lab Journal Wiki:General disclaimer">Disclaimers</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-poweredbyico">
						<a href="https://www.mediawiki.org/"><img src="resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="resources/assets/poweredby_mediawiki_132x47.png 1.5x, resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a><a href="https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAMAAABUFvrSAAACJVBMVEXe3t62trbLy8vGxsbAwMDX19e6urqsrKxHcEzQ0NC2tratra2oqKixsbHd3eDFxcXe3t7U1NTa2trX19fQ0NDV1dWNjY2dnZ2UlJSUlJTS0tKUlJSWlpbR0dGenp79/f38/Pz+/v7t7e3v7+/u7u7s7Oz19fX29vb6+vr7+/vz8/Pz8/P4+fnw8PD39/gWTq/09PX6+vktX7b/sg8XT7F6mc/f5OwhVrNvkMthhsfT2+j7rQ/M1eZqjcmFotPs7e9Cb722xuFResK/zOObstnu7/Grvd3M1+mNqNY6aLoaUbEaUbZWfsTk6fE2Zrnp7O8bTq0kWLQuYcpcg8Xh5/Byk83a4eukud1/nM+6yeQkWcGwwuDxnRQyYrigttvI0+gpW7XGyttLdsBni8geVLo0Z9XlkCPb4u+QqtcfVLLo7PNHcr73phFGX6HsmBnpkxg6bNwnXcbX3er19vnr7/SVrdhuhLl+j70vVqY6Xqv0oxJVcbQhV76DjKTz9ffQ2evE0OZAbbzu7/PS1uFufrDnrGgpSZjy8/SQnMFddrKuekXSiCsgTKRaaZHejy9yang3VptNaqspWbnmliy3j2/m6OzT3e7x8fL4+v3p6uwaN2re0cifqLiLiZWYhYGYb0xXYn+5g0xwiMKYpc2BcHZmW2srRXpGWIhecKfilz4+WID2+PyosMywqbGqss1aVnLZq33p1sGklZqrp7dkfr7CpY9yg59Ud6QZAAAAH3RSTlPfBN/f39/f2wDf39vV3/7N2rrEz5D5c8ONuHaPuXXDImoxqwAABO1JREFUSMe1kQdz01gQgBXaBS4w9OtHwMFSdPKTUNxkW+61xN2Je4tLHJNOGukkAUINJTzaUIbO9fr7TpLtS44DZiC5b6Sn3dW+TysJaWz4cv9eZFPZu/+bhkakYR88WqP59u3vjxzdDCT7GpCD4qNH3sEGzOhB5MCR/4PmA8j25uZ33t0A23lxff5hZTIzOrz2Ph8qK936l7i1tT7hk8DAoHNsbeLWKjPdQcZ+qvX9tHMNXca1XBDXHtL6x2Bh0HWtuXUo8oTgC1gVpcdsdpew92PUYtjwzFq+E9mJYfXxx1x5l2/l5Vhy0DW6TuyQCZcR2hnswXJM0h+203471u5WKMIE5mDpspIIO8sZTMZiIbczY6+JCaI+/sJZ38qjP28+nQjkx/mcqGJ26rW3iKg/fYphCL1jNk5WbqXI0nBnu00RJ2j9bNRp6MmFS0SYIXLuUlQ5w22qizHr5MTyy2u/3XxVvHHlwtWVa/xTCQIIlEaMzrgswzA5P9BrAciYASqNoiNdjL8b0GYAHN3AGAEgzPSQc9UtYCeyBQAMO2G9PhhzXfp9qdifSCT6Lj788QQnrvWEuNPI2um0LW0D+m4A6E4AnIZOeq7ksQuJvi6eUXRW+8EWXsxNPhkYGJiSXr7Rd1qtVp9MXHkgIurzAkdFxjrj7cmKbN4K5v8RGxT2sJMTpwBflNHhUJgBdoUylzy3TuwIDBRi0hf9p9VtbW3qk30X7q2Je1IybZq7mLVWFKTSADXPoqi9AzVorda0kKTS6KkRbSgaR1GT1h5CObYiW1GU27yc5z6F9Fn/yTYedeLi9AIA6AbgxGIxAMPZcZeUHH9cFavVfY97FaNA/DbazRZVV89/61at2BTlg1JXiFtrYoBmRyd7p6/UP0XxaSDmy4pt0jmuh8qx6wQ2MmRz18TaJCUWO9xisUVhMMsoZZDiGHLLuXUbso2iatP/1HvhYu3n3bh6Pe/LUjZSj1NUJ8lSlNwahRRlMRjmyFDICikVn8+SacomdbZTVj+0mQSxweS1WqpiHK/Ncubs858f9idOJ/qKS1cv+RbFuIbMmHEvTbO4QeF25CxyD62nSbmJ1MUzRrpiwR0RPBJMpnCGxWVGXBn8TkarNGQHjuPrxOeWY4GY9FmxWHy19Gvv+ayYF6f8oYi7i8U93bjFkYokvbhWEFu8Og2ZxrUe3NMpc3vLhqqYpVV4XbwDQkpgoVwYKOR9N5d+eXB5vJevQA0pD7oVqi4WOj16vX6EYSA08WKvyeOZJw1cQ6rsnXOa/RYoM0Kls0zLuVoHhHAHL8YFXkwVCoE8uXhvMVCY8mW5Ci8eKkcgJ9azOl0UajNDFiUpj5JeloEqTgwd/iCUJP0sFMSejkpO96b4zl1fPuYiyd6Vs4GBmHSsJoYmLy/WeBTlis5rlJYrgjhe1s+XOXGEtHJOMl4VB2EHLauKdyG7JBLIc//uslRKkhOrcGJqyiU9z5UkOpVOwiGXSyQizRAfqlRc7Y5KJFnV6FReiWSV7xAWeQd/SOSq6qY18eVHq4vjlyazEJ73ScmJPVxJVKdF9MFwYpFIEL+ehvDOcSH8YXRsAa4XfwS7kd0tLfw7Sp7fl7xJywbYjTTVotfTb+849lEcb0K+2lMN/5o+tons+Rxp+PrQ8U3n0BcNSGPj4W+bPuX5ZLNo+uxwY+PfoLJHX1KXgyMAAAAASUVORK5CYII=" alt="Powered by Semantic MediaWiki" class="smw-footer" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":93});});</script>
</body>
</html>
